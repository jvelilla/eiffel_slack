note
 description:"[
		Slack Web API
 		One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
  		The version of the OpenAPI document: 1.7.0
 	    

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	ADMIN_API

inherit

    API_I


feature -- API Access


	admin_apps_approve (token: STRING_32; app_id: STRING_32; request_id: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Approve an app for installation on a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.apps:write&#x60; (required)
			-- 
			-- argument: app_id The id of the app to approve. (optional, default to null)
			-- 
			-- argument: request_id The id of the request to approve. (optional, default to null)
			-- 
			-- argument: team_id  (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.apps.approve"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached app_id as l_app_id then
				l_request.add_form(l_app_id,"app_id");
			end
			if attached request_id as l_request_id then
				l_request.add_form(l_request_id,"request_id");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_apps_approved_list (token: STRING_32; limit: INTEGER_32; cursor: STRING_32; team_id: STRING_32; enterprise_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List approved apps for an org or workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.apps:read&#x60; (required)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional, default to null)
			-- 
			-- argument: team_id  (optional, default to null)
			-- 
			-- argument: enterprise_id  (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.apps.approved.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enterprise_id", enterprise_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_apps_requests_list (token: STRING_32; limit: INTEGER_32; cursor: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List app requests for a team/workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.apps:read&#x60; (required)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional, default to null)
			-- 
			-- argument: team_id  (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.apps.requests.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_apps_restrict (token: STRING_32; app_id: STRING_32; request_id: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Restrict an app for installation on a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.apps:write&#x60; (required)
			-- 
			-- argument: app_id The id of the app to restrict. (optional, default to null)
			-- 
			-- argument: request_id The id of the request to restrict. (optional, default to null)
			-- 
			-- argument: team_id  (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.apps.restrict"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached app_id as l_app_id then
				l_request.add_form(l_app_id,"app_id");
			end
			if attached request_id as l_request_id then
				l_request.add_form(l_request_id,"request_id");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_apps_restricted_list (token: STRING_32; limit: INTEGER_32; cursor: STRING_32; team_id: STRING_32; enterprise_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List restricted apps for an org or workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.apps:read&#x60; (required)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional, default to null)
			-- 
			-- argument: team_id  (optional, default to null)
			-- 
			-- argument: enterprise_id  (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.apps.restricted.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "enterprise_id", enterprise_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_archive (token: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Archive a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to archive. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.archive"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_convert_to_private (token: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Convert a public channel to a private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to convert to private. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.convertToPrivate"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_create (token: STRING_32; name: STRING_32; is_private: BOOLEAN; description: STRING_32; org_wide: BOOLEAN; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Create a public or private channel-based conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: name Name of the public or private channel to create. (required)
			-- 
			-- argument: is_private When &#x60;true&#x60;, creates a private channel instead of a public channel (required)
			-- 
			-- argument: description Description of the public or private channel to create. (optional, default to null)
			-- 
			-- argument: org_wide When &#x60;true&#x60;, the channel will be available org-wide. Note: if the channel is not &#x60;org_wide&#x3D;true&#x60;, you must specify a &#x60;team_id&#x60; for this channel (optional, default to null)
			-- 
			-- argument: team_id The workspace to create the channel in. Note: this argument is required unless you set &#x60;org_wide&#x3D;true&#x60;. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.create"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end
			if attached description as l_description then
				l_request.add_form(l_description,"description");
			end
			if attached is_private as l_is_private then
				l_request.add_form(l_is_private,"is_private");
			end
			if attached org_wide as l_org_wide then
				l_request.add_form(l_org_wide,"org_wide");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_delete (token: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Delete a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to delete. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.delete"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_disconnect_shared (token: STRING_32; channel_id: STRING_32; leaving_team_ids: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Disconnect a connected channel from one or more workspaces.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to be disconnected from some workspaces. (required)
			-- 
			-- argument: leaving_team_ids The team to be removed from the channel. Currently only a single team id can be specified. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.disconnectShared"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end
			if attached leaving_team_ids as l_leaving_team_ids then
				l_request.add_form(l_leaving_team_ids,"leaving_team_ids");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_ekm_list_original_connected_channel_info (token: STRING_32; channel_ids: STRING_32; team_ids: STRING_32; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all disconnected channels—i.e., channels that were once connected to other workspaces and then disconnected—and the corresponding original channel IDs for key revocation with EKM.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60; (required)
			-- 
			-- argument: channel_ids A comma-separated list of channels to filter to. (optional, default to null)
			-- 
			-- argument: team_ids A comma-separated list of the workspaces to which the channels you would like returned belong. (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.ekm.listOriginalConnectedChannelInfo"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel_ids", channel_ids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_ids", team_ids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_get_conversation_prefs (token: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Get conversation preferences for a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60; (required)
			-- 
			-- argument: channel_id The channel to get preferences for. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.getConversationPrefs"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel_id", channel_id));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_get_teams (token: STRING_32; channel_id: STRING_32; cursor: STRING_32; limit: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- Get all the workspaces a given public or private channel is connected to within this Enterprise org.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60; (required)
			-- 
			-- argument: channel_id The channel to determine connected workspaces within the organization for. (required)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.getTeams"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel_id", channel_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_invite (token: STRING_32; user_ids: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Invite a user to a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: user_ids The users to invite. (required)
			-- 
			-- argument: channel_id The channel that the users will be invited to. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.invite"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached user_ids as l_user_ids then
				l_request.add_form(l_user_ids,"user_ids");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_rename (token: STRING_32; channel_id: STRING_32; name: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Rename a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to rename. (required)
			-- 
			-- argument: name  (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.rename"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_restrict_access_add_group (token: STRING_32; group_id: STRING_32; channel_id: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Add an allowlist of IDP groups for accessing a channel
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: group_id The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to be an allowlist for the private channel. (required)
			-- 
			-- argument: channel_id The channel to link this group to. (required)
			-- 
			-- argument: team_id The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.restrictAccess.addGroup"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached group_id as l_group_id then
				l_request.add_form(l_group_id,"group_id");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_restrict_access_list_groups (token: STRING_32; channel_id: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all IDP Groups linked to a channel
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60; (required)
			-- 
			-- argument: channel_id  (required)
			-- 
			-- argument: team_id The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.restrictAccess.listGroups"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel_id", channel_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_restrict_access_remove_group (token: STRING_32; team_id: STRING_32; group_id: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Remove a linked IDP group linked from a private channel
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: team_id The workspace where the channel exists. This argument is required for channels only tied to one workspace, and optional for channels that are shared across an organization. (required)
			-- 
			-- argument: group_id The [IDP Group](https://slack.com/help/articles/115001435788-Connect-identity-provider-groups-to-your-Enterprise-Grid-org) ID to remove from the private channel. (required)
			-- 
			-- argument: channel_id The channel to remove the linked group from. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.restrictAccess.removeGroup"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached group_id as l_group_id then
				l_request.add_form(l_group_id,"group_id");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_search (token: STRING_32; team_ids: STRING_32; query: STRING_32; limit: INTEGER_32; cursor: STRING_32; search_channel_types: STRING_32; sort: STRING_32; sort_dir: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Search for public or private channels in an Enterprise organization.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:read&#x60; (required)
			-- 
			-- argument: team_ids Comma separated string of team IDs, signifying the workspaces to search through. (optional, default to null)
			-- 
			-- argument: query Name of the the channel to query by. (optional, default to null)
			-- 
			-- argument: limit Maximum number of items to be returned. Must be between 1 - 20 both inclusive. Default is 10. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional, default to null)
			-- 
			-- argument: search_channel_types The type of channel to include or exclude in the search. For example &#x60;private&#x60; will search private channels, while &#x60;private_exclude&#x60; will exclude them. For a full list of types, check the [Types section](#types). (optional, default to null)
			-- 
			-- argument: sort Possible values are &#x60;relevant&#x60; (search ranking based on what we think is closest), &#x60;name&#x60; (alphabetical), &#x60;member_count&#x60; (number of users in the channel), and &#x60;created&#x60; (date channel was created). You can optionally pair this with the &#x60;sort_dir&#x60; arg to change how it is sorted  (optional, default to null)
			-- 
			-- argument: sort_dir Sort direction. Possible values are &#x60;asc&#x60; for ascending order like (1, 2, 3) or (a, b, c), and &#x60;desc&#x60; for descending order like (3, 2, 1) or (c, b, a) (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.search"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_ids", team_ids));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "query", query));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "search_channel_types", search_channel_types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sort", sort));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "sort_dir", sort_dir));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_set_conversation_prefs (token: STRING_32; channel_id: STRING_32; prefs: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set the posting permissions for a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to set the prefs for (required)
			-- 
			-- argument: prefs The prefs for this channel in a stringified JSON format. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.setConversationPrefs"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end
			if attached prefs as l_prefs then
				l_request.add_form(l_prefs,"prefs");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_set_teams (token: STRING_32; channel_id: STRING_32; team_id: STRING_32; target_team_ids: STRING_32; org_channel: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- Set the workspaces in an Enterprise grid org that connect to a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The encoded &#x60;channel_id&#x60; to add or remove to workspaces. (required)
			-- 
			-- argument: team_id The workspace to which the channel belongs. Omit this argument if the channel is a cross-workspace shared channel. (optional, default to null)
			-- 
			-- argument: target_team_ids A comma-separated list of workspaces to which the channel should be shared. Not required if the channel is being shared org-wide. (optional, default to null)
			-- 
			-- argument: org_channel True if channel has to be converted to an org channel (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.setTeams"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached target_team_ids as l_target_team_ids then
				l_request.add_form(l_target_team_ids,"target_team_ids");
			end
			if attached org_channel as l_org_channel then
				l_request.add_form(l_org_channel,"org_channel");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_conversations_unarchive (token: STRING_32; channel_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Unarchive a public or private channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.conversations:write&#x60; (required)
			-- 
			-- argument: channel_id The channel to unarchive. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.conversations.unarchive"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel_id as l_channel_id then
				l_request.add_form(l_channel_id,"channel_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_emoji_add (token: STRING_32; name: STRING_32; url: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Add an emoji.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included. (required)
			-- 
			-- argument: url The URL of a file to use as an image for the emoji. Square images under 128KB and with transparent backgrounds work best. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.emoji.add"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end
			if attached url as l_url then
				l_request.add_form(l_url,"url");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_emoji_add_alias (token: STRING_32; name: STRING_32; alias_for: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Add an emoji alias.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: name The name of the emoji to be aliased. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included. (required)
			-- 
			-- argument: alias_for The alias of the emoji. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.emoji.addAlias"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end
			if attached alias_for as l_alias_for then
				l_request.add_form(l_alias_for,"alias_for");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_emoji_list (token: STRING_32; cursor: STRING_32; limit: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- List emoji for an Enterprise Grid organization.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:read&#x60; (required)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.emoji.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_emoji_remove (token: STRING_32; name: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Remove an emoji across an Enterprise Grid organization
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: name The name of the emoji to be removed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.emoji.remove"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_emoji_rename (token: STRING_32; name: STRING_32; new_name: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Rename an emoji.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: name The name of the emoji to be renamed. Colons (&#x60;:myemoji:&#x60;) around the value are not required, although they may be included. (required)
			-- 
			-- argument: new_name The new name of the emoji. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.emoji.rename"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end
			if attached new_name as l_new_name then
				l_request.add_form(l_new_name,"new_name");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_invite_requests_approve (token: STRING_32; invite_request_id: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Approve a workspace invite request.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.invites:write&#x60; (required)
			-- 
			-- argument: invite_request_id ID of the request to invite. (required)
			-- 
			-- argument: team_id ID for the workspace where the invite request was made. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.inviteRequests.approve"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached invite_request_id as l_invite_request_id then
				l_request.add_form(l_invite_request_id,"invite_request_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_invite_requests_approved_list (token: STRING_32; team_id: STRING_32; cursor: STRING_32; limit: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all approved workspace invite requests.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.invites:read&#x60; (required)
			-- 
			-- argument: team_id ID for the workspace where the invite requests were made. (optional, default to null)
			-- 
			-- argument: cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional, default to null)
			-- 
			-- argument: limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.inviteRequests.approved.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_invite_requests_denied_list (token: STRING_32; team_id: STRING_32; cursor: STRING_32; limit: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all denied workspace invite requests.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.invites:read&#x60; (required)
			-- 
			-- argument: team_id ID for the workspace where the invite requests were made. (optional, default to null)
			-- 
			-- argument: cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous api response (optional, default to null)
			-- 
			-- argument: limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000 both inclusive (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.inviteRequests.denied.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_invite_requests_deny (token: STRING_32; invite_request_id: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Deny a workspace invite request.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.invites:write&#x60; (required)
			-- 
			-- argument: invite_request_id ID of the request to invite. (required)
			-- 
			-- argument: team_id ID for the workspace where the invite request was made. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.inviteRequests.deny"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached invite_request_id as l_invite_request_id then
				l_request.add_form(l_invite_request_id,"invite_request_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_invite_requests_list (token: STRING_32; team_id: STRING_32; cursor: STRING_32; limit: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all pending workspace invite requests.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.invites:read&#x60; (required)
			-- 
			-- argument: team_id ID for the workspace where the invite requests were made. (optional, default to null)
			-- 
			-- argument: cursor Value of the &#x60;next_cursor&#x60; field sent as part of the previous API response (optional, default to null)
			-- 
			-- argument: limit The number of results that will be returned by the API on each invocation. Must be between 1 - 1000, both inclusive (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.inviteRequests.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_admins_list (token: STRING_32; team_id: STRING_32; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all of the admins on a given workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:read&#x60; (required)
			-- 
			-- argument: team_id  (required)
			-- 
			-- argument: limit The maximum number of items to return. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.admins.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_create (token: STRING_32; team_domain: STRING_32; team_name: STRING_32; team_description: STRING_32; team_discoverability: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Create an Enterprise team.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: team_domain Team domain (for example, slacksoftballteam). (required)
			-- 
			-- argument: team_name Team name (for example, Slack Softball Team). (required)
			-- 
			-- argument: team_description Description for the team. (optional, default to null)
			-- 
			-- argument: team_discoverability Who can join the team. A team&#39;s discoverability can be &#x60;open&#x60;, &#x60;closed&#x60;, &#x60;invite_only&#x60;, or &#x60;unlisted&#x60;. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.create"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_domain as l_team_domain then
				l_request.add_form(l_team_domain,"team_domain");
			end
			if attached team_name as l_team_name then
				l_request.add_form(l_team_name,"team_name");
			end
			if attached team_description as l_team_description then
				l_request.add_form(l_team_description,"team_description");
			end
			if attached team_discoverability as l_team_discoverability then
				l_request.add_form(l_team_discoverability,"team_discoverability");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_list (token: STRING_32; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all teams on an Enterprise organization
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:read&#x60; (required)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 100 both inclusive. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_owners_list (token: STRING_32; team_id: STRING_32; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- List all of the owners on a given workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:read&#x60; (required)
			-- 
			-- argument: team_id  (required)
			-- 
			-- argument: limit The maximum number of items to return. Must be between 1 - 1000 both inclusive. (optional, default to null)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.owners.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_settings_info (token: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Fetch information about settings in a workspace
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:read&#x60; (required)
			-- 
			-- argument: team_id  (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.settings.info"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_settings_set_default_channels (token: STRING_32; team_id: STRING_32; channel_ids: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set the default channels of a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: team_id ID for the workspace to set the default channel for. (required)
			-- 
			-- argument: channel_ids An array of channel IDs. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.settings.setDefaultChannels"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached channel_ids as l_channel_ids then
				l_request.add_form(l_channel_ids,"channel_ids");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_settings_set_description (token: STRING_32; team_id: STRING_32; description: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set the description of a given workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: team_id ID for the workspace to set the description for. (required)
			-- 
			-- argument: description The new description for the workspace. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.settings.setDescription"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached description as l_description then
				l_request.add_form(l_description,"description");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_settings_set_discoverability (token: STRING_32; team_id: STRING_32; discoverability: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- An API method that allows admins to set the discoverability of a given workspace
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: team_id The ID of the workspace to set discoverability on. (required)
			-- 
			-- argument: discoverability This workspace&#39;s discovery setting. It must be set to one of &#x60;open&#x60;, &#x60;invite_only&#x60;, &#x60;closed&#x60;, or &#x60;unlisted&#x60;. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.settings.setDiscoverability"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached discoverability as l_discoverability then
				l_request.add_form(l_discoverability,"discoverability");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_settings_set_icon (token: STRING_32; image_url: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Sets the icon of a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: image_url Image URL for the icon (required)
			-- 
			-- argument: team_id ID for the workspace to set the icon for. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.settings.setIcon"

			if attached token as l_token then
				l_request.add_form(l_token,"token");
			end
			if attached image_url as l_image_url then
				l_request.add_form(l_image_url,"image_url");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_teams_settings_set_name (token: STRING_32; team_id: STRING_32; name: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set the name of a given workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: team_id ID for the workspace to set the name for. (required)
			-- 
			-- argument: name The new name of the workspace. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.teams.settings.setName"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_usergroups_add_channels (token: STRING_32; usergroup_id: STRING_32; channel_ids: STRING_32; team_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Add one or more default channels to an IDP group.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60; (required)
			-- 
			-- argument: usergroup_id ID of the IDP group to add default channels for. (required)
			-- 
			-- argument: channel_ids Comma separated string of channel IDs. (required)
			-- 
			-- argument: team_id The workspace to add default channels in. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.usergroups.addChannels"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached usergroup_id as l_usergroup_id then
				l_request.add_form(l_usergroup_id,"usergroup_id");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached channel_ids as l_channel_ids then
				l_request.add_form(l_channel_ids,"channel_ids");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_usergroups_add_teams (token: STRING_32; usergroup_id: STRING_32; team_ids: STRING_32; auto_provision: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- Associate one or more default workspaces with an organization-wide IDP group.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.teams:write&#x60; (required)
			-- 
			-- argument: usergroup_id An encoded usergroup (IDP Group) ID. (required)
			-- 
			-- argument: team_ids A comma separated list of encoded team (workspace) IDs. Each workspace *MUST* belong to the organization associated with the token. (required)
			-- 
			-- argument: auto_provision When &#x60;true&#x60;, this method automatically creates new workspace accounts for the IDP group members. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.usergroups.addTeams"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached usergroup_id as l_usergroup_id then
				l_request.add_form(l_usergroup_id,"usergroup_id");
			end
			if attached team_ids as l_team_ids then
				l_request.add_form(l_team_ids,"team_ids");
			end
			if attached auto_provision as l_auto_provision then
				l_request.add_form(l_auto_provision,"auto_provision");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_usergroups_list_channels (token: STRING_32; usergroup_id: STRING_32; team_id: STRING_32; include_num_members: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- List the channels linked to an org-level IDP group (user group).
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.usergroups:read&#x60; (required)
			-- 
			-- argument: usergroup_id ID of the IDP group to list default channels for. (required)
			-- 
			-- argument: team_id ID of the the workspace. (optional, default to null)
			-- 
			-- argument: include_num_members Flag to include or exclude the count of members per channel. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.usergroups.listChannels"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "usergroup_id", usergroup_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "include_num_members", include_num_members));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_usergroups_remove_channels (token: STRING_32; usergroup_id: STRING_32; channel_ids: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Remove one or more default channels from an org-level IDP group (user group).
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.usergroups:write&#x60; (required)
			-- 
			-- argument: usergroup_id ID of the IDP Group (required)
			-- 
			-- argument: channel_ids Comma-separated string of channel IDs (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.usergroups.removeChannels"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached usergroup_id as l_usergroup_id then
				l_request.add_form(l_usergroup_id,"usergroup_id");
			end
			if attached channel_ids as l_channel_ids then
				l_request.add_form(l_channel_ids,"channel_ids");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_assign (token: STRING_32; team_id: STRING_32; user_id: STRING_32; is_restricted: BOOLEAN; is_ultra_restricted: BOOLEAN; channel_ids: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Add an Enterprise user to a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: user_id The ID of the user to add to the workspace. (required)
			-- 
			-- argument: is_restricted True if user should be added to the workspace as a guest. (optional, default to null)
			-- 
			-- argument: is_ultra_restricted True if user should be added to the workspace as a single-channel guest. (optional, default to null)
			-- 
			-- argument: channel_ids Comma separated values of channel IDs to add user in the new workspace. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.assign"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end
			if attached is_restricted as l_is_restricted then
				l_request.add_form(l_is_restricted,"is_restricted");
			end
			if attached is_ultra_restricted as l_is_ultra_restricted then
				l_request.add_form(l_is_ultra_restricted,"is_ultra_restricted");
			end
			if attached channel_ids as l_channel_ids then
				l_request.add_form(l_channel_ids,"channel_ids");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_invite (token: STRING_32; team_id: STRING_32; email: STRING_32; channel_ids: STRING_32; custom_message: STRING_32; real_name: STRING_32; resend: BOOLEAN; is_restricted: BOOLEAN; is_ultra_restricted: BOOLEAN; guest_expiration_ts: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Invite a user to a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: email The email address of the person to invite. (required)
			-- 
			-- argument: channel_ids A comma-separated list of &#x60;channel_id&#x60;s for this user to join. At least one channel is required. (required)
			-- 
			-- argument: custom_message An optional message to send to the user in the invite email. (optional, default to null)
			-- 
			-- argument: real_name Full name of the user. (optional, default to null)
			-- 
			-- argument: resend Allow this invite to be resent in the future if a user has not signed up yet. (default: false) (optional, default to null)
			-- 
			-- argument: is_restricted Is this user a multi-channel guest user? (default: false) (optional, default to null)
			-- 
			-- argument: is_ultra_restricted Is this user a single channel guest user? (default: false) (optional, default to null)
			-- 
			-- argument: guest_expiration_ts Timestamp when guest account should be disabled. Only include this timestamp if you are inviting a guest user and you want their account to expire on a certain date. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.invite"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached email as l_email then
				l_request.add_form(l_email,"email");
			end
			if attached channel_ids as l_channel_ids then
				l_request.add_form(l_channel_ids,"channel_ids");
			end
			if attached custom_message as l_custom_message then
				l_request.add_form(l_custom_message,"custom_message");
			end
			if attached real_name as l_real_name then
				l_request.add_form(l_real_name,"real_name");
			end
			if attached resend as l_resend then
				l_request.add_form(l_resend,"resend");
			end
			if attached is_restricted as l_is_restricted then
				l_request.add_form(l_is_restricted,"is_restricted");
			end
			if attached is_ultra_restricted as l_is_ultra_restricted then
				l_request.add_form(l_is_ultra_restricted,"is_ultra_restricted");
			end
			if attached guest_expiration_ts as l_guest_expiration_ts then
				l_request.add_form(l_guest_expiration_ts,"guest_expiration_ts");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_list (token: STRING_32; team_id: STRING_32; cursor: STRING_32; limit: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- List users on a workspace
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:read&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: cursor Set &#x60;cursor&#x60; to &#x60;next_cursor&#x60; returned by the previous call to list items in the next page. (optional, default to null)
			-- 
			-- argument: limit Limit for how many users to be retrieved per page (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team_id", team_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_remove (token: STRING_32; team_id: STRING_32; user_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Remove a user from a workspace.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: user_id The ID of the user to remove. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.remove"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_session_invalidate (token: STRING_32; team_id: STRING_32; session_id: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- Invalidate a single session for a user by session_id
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id ID of the team that the session belongs to (required)
			-- 
			-- argument: session_id  (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.session.invalidate"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached session_id as l_session_id then
				l_request.add_form(l_session_id,"session_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_session_reset (token: STRING_32; user_id: STRING_32; mobile_only: BOOLEAN; web_only: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- Wipes all valid sessions on all devices for a given user
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: user_id The ID of the user to wipe sessions for (required)
			-- 
			-- argument: mobile_only Only expire mobile sessions (default: false) (optional, default to null)
			-- 
			-- argument: web_only Only expire web sessions (default: false) (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.session.reset"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end
			if attached mobile_only as l_mobile_only then
				l_request.add_form(l_mobile_only,"mobile_only");
			end
			if attached web_only as l_web_only then
				l_request.add_form(l_web_only,"web_only");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_set_admin (token: STRING_32; team_id: STRING_32; user_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set an existing guest, regular user, or owner to be an admin user.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: user_id The ID of the user to designate as an admin. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.setAdmin"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_set_expiration (token: STRING_32; team_id: STRING_32; user_id: STRING_32; expiration_ts: INTEGER_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set an expiration for a guest user
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: user_id The ID of the user to set an expiration for. (required)
			-- 
			-- argument: expiration_ts Timestamp when guest account should be disabled. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.setExpiration"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end
			if attached expiration_ts as l_expiration_ts then
				l_request.add_form(l_expiration_ts,"expiration_ts");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_set_owner (token: STRING_32; team_id: STRING_32; user_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set an existing guest, regular user, or admin user to be a workspace owner.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: user_id Id of the user to promote to owner. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.setOwner"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	admin_users_set_regular (token: STRING_32; team_id: STRING_32; user_id: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Set an existing guest user, admin user, or owner to be a regular user.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin.users:write&#x60; (required)
			-- 
			-- argument: team_id The ID (&#x60;T1234&#x60;) of the workspace. (required)
			-- 
			-- argument: user_id The ID of the user to designate as a regular user. (required)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/admin.users.setRegular"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached team_id as l_team_id then
				l_request.add_form(l_team_id,"team_id");
			end
			if attached user_id as l_user_id then
				l_request.add_form(l_user_id,"user_id");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
