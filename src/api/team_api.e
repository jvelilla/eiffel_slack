note
 description:"[
		Slack Web API
 		One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
  		The version of the OpenAPI document: 1.7.0
 	    

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	TEAM_API

inherit

    API_I


feature -- API Access


	team_access_logs (token: STRING_32; before: STRING_32; count: STRING_32; page: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Gets the access logs for the current team.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin&#x60; (required)
			-- 
			-- argument: before End of time range of logs to include in results (inclusive). (optional, default to null)
			-- 
			-- argument: count  (optional, default to null)
			-- 
			-- argument: page  (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/team.accessLogs"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "before", before));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "count", count));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "page", page));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	team_billable_info (token: STRING_32; user: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Gets billable users information for the current team.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin&#x60; (required)
			-- 
			-- argument: user A user to retrieve the billable information for. Defaults to all users. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/team.billableInfo"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user", user));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	team_info (token: STRING_32; team: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Gets information about the current team.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;team:read&#x60; (required)
			-- 
			-- argument: team Team to get info on, if omitted, will return information about the current team. Will only return team that the authenticated token is allowed to see through external shared channels (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/team.info"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "team", team));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	team_integration_logs (token: STRING_32; app_id: STRING_32; change_type: STRING_32; count: STRING_32; page: STRING_32; service_id: STRING_32; user: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Gets the integration logs for the current team.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;admin&#x60; (required)
			-- 
			-- argument: app_id Filter logs to this Slack app. Defaults to all logs. (optional, default to null)
			-- 
			-- argument: change_type Filter logs with this change type. Defaults to all logs. (optional, default to null)
			-- 
			-- argument: count  (optional, default to null)
			-- 
			-- argument: page  (optional, default to null)
			-- 
			-- argument: service_id Filter logs to this service. Defaults to all logs. (optional, default to null)
			-- 
			-- argument: user Filter logs generated by this userâ€™s actions. Defaults to all logs. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/team.integrationLogs"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "app_id", app_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "change_type", change_type));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "count", count));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "page", page));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "service_id", service_id));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "user", user));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	team_profile_get (token: STRING_32; visibility: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Retrieve a team&#39;s profile.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;users.profile:read&#x60; (required)
			-- 
			-- argument: visibility Filter by visibility. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/team.profile.get"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "visibility", visibility));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
