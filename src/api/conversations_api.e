note
 description:"[
		Slack Web API
 		One way to interact with the Slack platform is its HTTP RPC-based Web API, a collection of methods requiring OAuth 2.0-based user, bot, or workspace tokens blessed with related OAuth scopes.
  		The version of the OpenAPI document: 1.7.0
 	    

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"

class
	CONVERSATIONS_API

inherit

    API_I


feature -- API Access


	conversations_archive (token: STRING_32; channel: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Archives a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel ID of conversation to archive (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.archive"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_close (token: STRING_32; channel: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Closes a direct message or multi-person direct message.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation to close. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.close"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_create (token: STRING_32; name: STRING_32; is_private: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- Initiates a public or private channel-based conversation
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: name Name of the public or private channel to create (optional, default to null)
			-- 
			-- argument: is_private Create a private channel instead of a public one (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.create"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end
			if attached is_private as l_is_private then
				l_request.add_form(l_is_private,"is_private");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_history (token: STRING_32; channel: STRING_32; latest: REAL_32; oldest: REAL_32; inclusive: BOOLEAN; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Fetches a conversation&#39;s history of messages and events.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation ID to fetch history for. (optional, default to null)
			-- 
			-- argument: latest End of time range of messages to include in results. (optional, default to null)
			-- 
			-- argument: oldest Start of time range of messages to include in results. (optional, default to null)
			-- 
			-- argument: inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional, default to null)
			-- 
			-- argument: cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.history"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel", channel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "latest", latest));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oldest", oldest));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "inclusive", inclusive));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_info (token: STRING_32; channel: STRING_32; include_locale: BOOLEAN; include_num_members: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- Retrieve information about a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation ID to learn more about (optional, default to null)
			-- 
			-- argument: include_locale Set this to &#x60;true&#x60; to receive the locale for this conversation. Defaults to &#x60;false&#x60; (optional, default to null)
			-- 
			-- argument: include_num_members Set to &#x60;true&#x60; to include the member count for the specified conversation. Defaults to &#x60;false&#x60; (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.info"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel", channel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "include_locale", include_locale));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "include_num_members", include_num_members));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_invite (token: STRING_32; channel: STRING_32; users: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Invites users to a channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel The ID of the public or private channel to invite user(s) to. (optional, default to null)
			-- 
			-- argument: users A comma separated list of user IDs. Up to 1000 users may be listed. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.invite"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached users as l_users then
				l_request.add_form(l_users,"users");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_join (token: STRING_32; channel: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Joins an existing conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;channels:write&#x60; (optional, default to null)
			-- 
			-- argument: channel ID of conversation to join (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.join"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_kick (token: STRING_32; channel: STRING_32; user: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Removes a user from a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel ID of conversation to remove user from. (optional, default to null)
			-- 
			-- argument: user User ID to be removed. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.kick"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached user as l_user then
				l_request.add_form(l_user,"user");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_leave (token: STRING_32; channel: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Leaves a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation to leave (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.leave"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_list (token: STRING_32; exclude_archived: BOOLEAN; types: STRING_32; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Lists all channels in a Slack team.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional, default to null)
			-- 
			-- argument: exclude_archived Set to &#x60;true&#x60; to exclude archived channels from the list (optional, default to null)
			-- 
			-- argument: types Mix and match channel types by providing a comma-separated list of any combination of &#x60;public_channel&#x60;, &#x60;private_channel&#x60;, &#x60;mpim&#x60;, &#x60;im&#x60; (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the list hasn&#39;t been reached. Must be an integer no larger than 1000. (optional, default to null)
			-- 
			-- argument: cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.list"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "exclude_archived", exclude_archived));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "types", types));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_mark (token: STRING_32; channel: STRING_32; ts: REAL_32): detachable STRING_TABLE [ANY]
			-- 
			-- Sets the read cursor in a channel.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel Channel or conversation to set the read cursor for. (optional, default to null)
			-- 
			-- argument: ts Unique identifier of message you want marked as most recently seen in this conversation. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.mark"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached ts as l_ts then
				l_request.add_form(l_ts,"ts");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_members (token: STRING_32; channel: STRING_32; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Retrieve members of a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:read&#x60; (optional, default to null)
			-- 
			-- argument: channel ID of the conversation to retrieve members for (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional, default to null)
			-- 
			-- argument: cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.members"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel", channel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_open (token: STRING_32; channel: STRING_32; users: STRING_32; return_im: BOOLEAN): detachable STRING_TABLE [ANY]
			-- 
			-- Opens or resumes a direct message or multi-person direct message.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel Resume a conversation by supplying an &#x60;im&#x60; or &#x60;mpim&#x60;&#39;s ID. Or provide the &#x60;users&#x60; field instead. (optional, default to null)
			-- 
			-- argument: users Comma separated lists of users. If only one user is included, this creates a 1:1 DM.  The ordering of the users is preserved whenever a multi-person direct message is returned. Supply a &#x60;channel&#x60; when not supplying &#x60;users&#x60;. (optional, default to null)
			-- 
			-- argument: return_im Boolean, indicates you want the full IM channel definition in the response. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.open"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached users as l_users then
				l_request.add_form(l_users,"users");
			end
			if attached return_im as l_return_im then
				l_request.add_form(l_return_im,"return_im");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_rename (token: STRING_32; channel: STRING_32; name: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Renames a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel ID of conversation to rename (optional, default to null)
			-- 
			-- argument: name New name for conversation. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.rename"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached name as l_name then
				l_request.add_form(l_name,"name");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_replies (token: STRING_32; channel: STRING_32; ts: REAL_32; latest: REAL_32; oldest: REAL_32; inclusive: BOOLEAN; limit: INTEGER_32; cursor: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Retrieve a thread of messages posted to a conversation
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:history&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation ID to fetch thread from. (optional, default to null)
			-- 
			-- argument: ts Unique identifier of a thread&#39;s parent message. &#x60;ts&#x60; must be the timestamp of an existing message with 0 or more replies. If there are no replies then just the single message referenced by &#x60;ts&#x60; will return - it is just an ordinary, unthreaded message. (optional, default to null)
			-- 
			-- argument: latest End of time range of messages to include in results. (optional, default to null)
			-- 
			-- argument: oldest Start of time range of messages to include in results. (optional, default to null)
			-- 
			-- argument: inclusive Include messages with latest or oldest timestamp in results only when either timestamp is specified. (optional, default to null)
			-- 
			-- argument: limit The maximum number of items to return. Fewer than the requested number of items may be returned, even if the end of the users list hasn&#39;t been reached. (optional, default to null)
			-- 
			-- argument: cursor Paginate through collections of data by setting the &#x60;cursor&#x60; parameter to a &#x60;next_cursor&#x60; attribute returned by a previous request&#39;s &#x60;response_metadata&#x60;. Default value fetches the first \&quot;page\&quot; of the collection. See [pagination](/docs/pagination) for more detail. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.replies"
			l_request.fill_query_params(api_client.parameter_to_tuple("", "token", token));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "channel", channel));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "ts", ts));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "latest", latest));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "oldest", oldest));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "inclusive", inclusive));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "limit", limit));
			l_request.fill_query_params(api_client.parameter_to_tuple("", "cursor", cursor));


			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<>>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Get", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_set_purpose (token: STRING_32; channel: STRING_32; purpose: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Sets the purpose for a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation to set the purpose of (optional, default to null)
			-- 
			-- argument: purpose A new, specialer purpose (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.setPurpose"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached purpose as l_purpose then
				l_request.add_form(l_purpose,"purpose");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_set_topic (token: STRING_32; channel: STRING_32; topic: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Sets the topic for a conversation.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel Conversation to set the topic of (optional, default to null)
			-- 
			-- argument: topic The new topic string. Does not support formatting or linkification. (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.setTopic"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end
			if attached topic as l_topic then
				l_request.add_form(l_topic,"topic");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	

	conversations_unarchive (token: STRING_32; channel: STRING_32): detachable STRING_TABLE [ANY]
			-- 
			-- Reverses conversation archival.
			-- 
			-- argument: token Authentication token. Requires scope: &#x60;conversations:write&#x60; (optional, default to null)
			-- 
			-- argument: channel ID of conversation to unarchive (optional, default to null)
			-- 
			-- 
			-- Result STRING_TABLE [ANY]
		require
		local
  			l_path: STRING
  			l_request: API_CLIENT_REQUEST
  			l_response: API_CLIENT_RESPONSE
		do
			reset_error
			create l_request
			
			l_path := "/conversations.unarchive"

			if attached token as l_token then
				l_request.add_header(l_token.out,"token");
			end
			if attached channel as l_channel then
				l_request.add_form(l_channel,"channel");
			end

			if attached {STRING} api_client.select_header_accept ({ARRAY [STRING]}<<"application/json">>)  as l_accept then
				l_request.add_header(l_accept,"Accept");
			end
			l_request.add_header(api_client.select_header_content_type ({ARRAY [STRING]}<<"application/x-www-form-urlencoded", "application/json">>),"Content-Type")
			l_request.set_auth_names ({ARRAY [STRING]}<<"slackAuth">>)
			l_response := api_client.call_api (l_path, "Post", l_request, Void, agent deserializer)
			if l_response.has_error then
				last_error := l_response.error
			elseif attached { STRING_TABLE [ANY] } l_response.data ({ STRING_TABLE [ANY] }) as l_data then
				Result := l_data
			else
				create last_error.make ("Unknown error: Status response [ " + l_response.status.out + "]")
			end
		end	


end
